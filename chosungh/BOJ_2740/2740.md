# 2740 풀이방법 및 트러블슈팅

---

### 문제
N*M크기의 행렬 A와 M*K크기의 행렬 B가 주어졌을 때, 두 행렬을 곱하는 프로그램을 작성하시오.

---

### 입력
첫째 줄에 행렬 A의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 순서대로 주어진다. 그 다음 줄에는 행렬 B의 크기 M과 K가 주어진다. 이어서 M개의 줄에 행렬 B의 원소 K개가 차례대로 주어진다. N과 M, 그리고 K는 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다.

```bash
3 2
1 2
3 4
5 6
2 3
-1 -2 0
0 0 3
```

---

### 출력
첫째 줄부터 N개의 줄에 행렬 A와 B를 곱한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다.

```bash
-1 -2 6
-3 -6 12
-5 -10 18
```

---

### 풀이 전략
이 문제는 행렬의 곱셈과 관련된 문제로, 수학적 논리가 맞는지 확인하며 풀었습니다. 

---

### 첫 번째 트러블슈팅

```python
import sys
input = sys.stdin.readline

mul_mat = []

mat_A = []
mat_A_row, mat_A_column = map(int, input().split())

for i in range(mat_A_row):
    mat_A.append(list(map(int, input().split())))

mat_B = []
mat_B_row, mat_B_column = map(int, input().split())

for i in range(mat_B_row):
    mat_B.append(list(map(int, input().split())))

for i in range(mat_A_row):
    for j in range(mat_B_column):
        temp = []
        temp.append(mat_A[i][0] * mat_B[0][j])
        temp.append(mat_A[i][1] * mat_B[1][j])
        print(f'{j}번째 실행: {temp}')
    mul_mat.append(temp)

print(mat_A)
print(mat_B)

print(mul_mat)
```

##### 문제점
행렬의 곱셈에서는 `temp.append(mat_A[i][0] * mat_B[0][j])`, `temp.append(mat_A[i][1] * mat_B[1][j])` 이 두 곱의 합을 덧셈을 해야 하지만 값을 따로 저장하였기에 값이 제대로 출력되지 않았습니다. 

---

### 두 번째 트러블슈팅

```py
import sys
input = sys.stdin.readline

mul_mat = []

mat_A = []
mat_A_row, mat_A_column = map(int, input().split())

for i in range(mat_A_row):
    mat_A.append(list(map(int, input().split())))

mat_B = []
mat_B_row, mat_B_column = map(int, input().split())

for i in range(mat_B_row):
    mat_B.append(list(map(int, input().split())))

for i in range(mat_A_row):
    temp = []
    for j in range(mat_B_column):
        temp_a = mat_A[i][0] * mat_B[0][j]
        temp_b = mat_A[i][1] * mat_B[1][j]
        temp.append(temp_a + temp_b)
    mul_mat.append(temp)

for row in mul_mat:
    for item in row:
        print(item, end=" ")
    print()
```

##### 문제점
2704 문제의 입력형식만을 생각하여 각각의 행과 열의 개수가 달라졌을 때를 고려하지 않았습니다. `mat_A[i][0]`처럼 하드코딩하여 행과 열의 개수가 달라졌을 때에는 잘못된 계산을 하도록 코딩하였습니다.

---

### 최종 답안

```python
import sys
input = sys.stdin.readline

mul_mat = []

mat_A = []
mat_A_row, mat_A_column = map(int, input().split())

for i in range(mat_A_row):
    mat_A.append(list(map(int, input().split())))

mat_B = []
mat_B_row, mat_B_column = map(int, input().split())

for i in range(mat_B_row):
    mat_B.append(list(map(int, input().split())))

for i in range(mat_A_row):
    temp = []
    for j in range(mat_B_column):
        temp_item = 0
        for k in range(mat_A_column):
            temp_item += mat_A[i][k] * mat_B[k][j]
        temp.append(temp_item)
    mul_mat.append(temp)

for row in mul_mat:
    for item in row:
        print(item, end=" ")
    print()
```

---

### 시간 복잡도
- 첫 번째 트러블슈팅: O(n * m)
- 두 번째 트러블슈팅: O(n * m)
- 최종 답안: O(n * m * k)