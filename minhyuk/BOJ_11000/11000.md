# [BOJ] 11000 강의실 배정

## 문제 전략

1. **정렬을 이용한 그리디 접근**: 강의를 시작 시간 기준으로 오름차순 정렬하여, 시간순으로 강의를 배정합니다.
2. **최소 힙(Min Heap) 활용**: 현재 사용 중인 강의실들의 종료 시간을 최소 힙으로 관리합니다. 힙의 루트는 가장 빨리 끝나는 강의실의 종료 시간입니다.
3. **강의실 재사용 판단**: 새 강의의 시작 시간이 가장 빨리 끝나는 강의실의 종료 시간 이상이면 해당 강의실을 재사용하고, 그렇지 않으면 새 강의실을 추가합니다.

## 해결 과정

1. `n`개의 강의 정보(시작 시간, 종료 시간)를 `lecture` 리스트에 저장합니다.
2. `lecture.sort()`를 통해 시작 시간 기준으로 오름차순 정렬합니다.
3. 첫 번째 강의의 종료 시간을 힙에 넣어 초기화합니다.
4. 두 번째 강의부터 순회하며:
   - 새 강의의 시작 시간 `>=` 힙의 최솟값(가장 빨리 끝나는 시간)이면 `heappop`으로 해당 강의실을 비웁니다.
   - 새 강의의 종료 시간을 `heappush`로 힙에 추가합니다.
5. 모든 강의 배정 후 힙의 크기가 필요한 최소 강의실 수입니다.

## 복잡도 분석

### 시간 복잡도: $O(N \log N)$
- **정렬**: `lecture.sort()`는 O(N \log N)이 소요됩니다.
- **힙 연산**: $N$개의 강의에 대해 각각 `heappush`와 `heappop`(최대 1회)을 수행하므로 $O(N \log N)$입니다.
- **결론**: 전체 시간 복잡도는 **O(N \log N)**입니다.

### 공간 복잡도: $O(N)$
- 최악의 경우 모든 강의가 겹쳐 힙에 $N$개의 원소가 저장됩니다.

## 어려웠던점

- **초기 접근 방식의 시간 초과**: 처음에는 정렬 없이 `deque`에서 강의를 하나씩 꺼내며 `result` 리스트를 순회하여 강의실을 배정하는 방식을 사용했습니다. 이 경우 매 강의마다 모든 강의실을 탐색해야 해서 $O(N^2)$의 시간 복잡도가 발생하여 시간 초과가 발생했습니다.
- **해결**: 강의를 시작 시간 기준으로 정렬하고, 최소 힙을 사용하여 가장 빨리 끝나는 강의실만 확인하는 방식으로 개선했습니다. 이를 통해 O(N \log N)으로 시간 복잡도를 줄일 수 있었습니다.
